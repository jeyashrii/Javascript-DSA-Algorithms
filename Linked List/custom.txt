1. What Are We Creating?
We're building a Linked List data structure, where:

Each element (or node) contains some data (a value) and a pointer/reference to the next element.
The list maintains references to the first element (head) and the last element (tail) for efficient access.
The list also keeps track of its length.
2. What Classes Do We Need?
Node Class:
Represents an individual element in the list.
Contains:
value (the data stored in the node).
next (a reference to the next node in the list, or null if it's the last node).
Code for Node Class:
js

class Node {
  constructor(value) {
    this.value = value;  // The data the node stores
    this.next = null;    // The next node in the list (or null if no next node)
  }
}
Why do we need the Node class?
It allows us to create individual elements of the linked list and link them together.
LinkedList Class:
Represents the overall list structure.
Contains:
head: A reference to the first node in the list.
tail: A reference to the last node in the list.
length: The number of nodes in the list.
Code for LinkedList Class:
js

class LinkedList {
  constructor(value) {
    // Create the first node and assign it to both head and tail
    this.head = new Node(value);
    this.tail = this.head;
    this.length = 1;
  }
}
Why do we need the LinkedList class?
It manages the entire structure of the list and provides methods to manipulate the nodes.
3. How Do We Add Methods to the LinkedList?
Pushing a Node to the End:
Adds a new node to the end of the list.
Updates the tail to point to the new node.
Increments the length of the list.
Code for push() Method:
js

push(value) {
  let newNode = new Node(value);

  // If the list is empty (though the constructor should ensure this isn't the case)
  if (!this.head) {
    this.head = newNode;
    this.tail = newNode;
  } else {
    // Attach the new node at the end and update the tail
    this.tail.next = newNode;
    this.tail = newNode;
  }

  // Increment the length of the list
  this.length++;
}
Popping a Node from the End:
Removes the last node from the list.
Updates the tail to be the second-to-last node.
If the list becomes empty, head and tail are set to null.
Decrements the length.
Code for pop() Method:
js

pop() {
  // If the list is empty, return undefined
  if (!this.head) return undefined;

  let temp = this.head;
  let prev = this.head;

  // Traverse to the end of the list
  while (temp.next) {
    prev = temp;
    temp = temp.next;
  }

  // Set the new tail to the second-to-last node
  this.tail = prev;
  this.tail.next = null;

  // Decrement the length of the list
  this.length--;

  // If the list is now empty, set head and tail to null
  if (this.length === 0) {
    this.head = null;
    this.tail = null;
  }

  // Return the removed node
  return temp;
}
4. Key Questions Addressed:
Why Use Separate Classes for Node and LinkedList?
The Node class focuses on representing a single element of the list, while the LinkedList class manages the overall structure.
Separation of concerns: Each class has a specific role. The Node is simple and self-contained, while LinkedList handles list-level operations like adding, removing, and tracking nodes.
Why Is tail Part of LinkedList and Not Node?
The tail represents the end of the entire list, not just a property of an individual node. Managing the tail in the LinkedList allows efficient access and updates when adding or removing nodes from the end of the list.
What Are head and tail?
head: Points to the first node in the list.
tail: Points to the last node in the list.
These are user-defined names, but they follow standard convention and make the code more readable and understandable.
What Happens When the List Becomes Empty?
After the last node is removed (pop()), both head and tail are set to null, and the length is set to 0 to indicate the list is empty.
5. Other Common Operations in a Linked List:
Removing the First Node (Shift):
Removes the node at the start of the list, updates the head, and decreases the length.

Code for shift() Method:
js

shift() {
  if (!this.head) return undefined; // If the list is empty, return undefined
  
  let temp = this.head;
  this.head = this.head.next;
  this.length--;
  
  if (this.length === 0) {
    this.tail = null; // If the list is now empty, set the tail to null
  }
  
  return temp; // Return the removed node
}
Adding a Node to the Start (Unshift):
Adds a node to the beginning of the list and updates the head.

Code for unshift() Method:
js

unshift(value) {
  let newNode = new Node(value);

  if (!this.head) {
    this.head = newNode;
    this.tail = newNode;
  } else {
    newNode.next = this.head;
    this.head = newNode;
  }

  this.length++;
  return this;
}
6. Full Example of a Linked List:
js

class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor(value) {
    this.head = new Node(value);
    this.tail = this.head;
    this.length = 1;
  }

  push(value) {
    let newNode = new Node(value);
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
  }

  pop() {
    if (!this.head) return undefined;

    let temp = this.head;
    let prev = this.head;

    while (temp.next) {
      prev = temp;
      temp = temp.next;
    }

    this.tail = prev;
    this.tail.next = null;
    this.length--;

    if (this.length === 0) {
      this.head = null;
      this.tail = null;
    }

    return temp;
  }

  shift() {
    if (!this.head) return undefined;
    
    let temp = this.head;
    this.head = this.head.next;
    this.length--;
    
    if (this.length === 0) {
      this.tail = null;
    }

    return temp;
  }

  unshift(value) {
    let newNode = new Node(value);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head = newNode;
    }

    this.length++;
  }
}
---------------------------------------getLast()

| **Aspect**       | **Original Method** (`return this.tail`) | **New Method** (traversal-based) |
|-------------------|------------------------------------------|-----------------------------------|
| **Efficiency**    | O(1)                                    | O(n)                             |
| **Reliability**   | Depends on a properly maintained `tail` | Independent of `tail` property   |
| **Implementation**| Simple direct access to `tail`          | Traverses the list dynamically   |
| **Use Case**      | Fast for well-maintained lists          | Works even if `tail` is missing  |
